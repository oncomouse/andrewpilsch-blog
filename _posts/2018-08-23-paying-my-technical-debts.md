---
layout: post
title: Paying My Technical Debts
date: 2018-08-23 12:42 -0500
published: false
---

I've implemented redesigns on both this blog and [my main site](https://andrew.pilsch.com), as you may or may not have noticed. However, even with the overhaul of the sites, what is happening behind the scenes represents even bigger changes. I have switched both sites from my go-to static site generator, [Middleman](https://middlemanapp.com) to the more widely used [Jekyll](http://jekyllrb.com). Overall, the new site makes implementing changes and maintaining the code easier in the long run. Additionally, I am happy to be finally working with Jekyll, which is a change I've known I need to make for a while.

This redesign has also gotten me thinking about recent reading I've been doing on a number of tech start-ups' engineering blogs. I've noticed that many big companies, such as AirBnb, Uber, and Facebook, talk at length about "technical debt" when they speak about changes they are making to their front-end or back-end code. Technical debt is a concept in software engineering that considers investment in particular technologies to be akin to financial investments, some of which result in losses. [Wikipedia](https://en.wikipedia.org/wiki/Technical_debt) suggests that the concept "reflects the implied cost of additional rework caused by choosing an easy solution now instead of using a better approach that would take longer." The article continues:

> Technical debt can be compared to monetary debt. If technical debt is not repaid, it can accumulate 'interest', making it harder to implement changes later on. Unaddressed technical debt increases software entropy. 

There are two categories of technical debt: **deliberate or inadvertent** and **reckless or prudent**. Combined these four categories describe different decisions made during the development process that can lead to the accumulation of debt.

Like economic debt, technical debt demands continual interest payments. Bad technical decisions, even ones that we make without intending to (like I did with Middleman), continue being bad technical decisions. Even later good decisions have to be implemented in concert with or in spite of previous bad decisions.

A classic example of this form of debt is the x86 CPU architecture that powers most desktop computers (Intel and AMD chips are all x86). First designed between 1976 and 1978 for Intel's 8086 chip, the x86 instruction set became the defacto standard for personal computers when the 8088 was included in IBM's first PC. However, over the intervening years, there was a major sea change in the design of CPU instruction sets with the maturation of what is called RISC architectures (**R**educed **I**nstruction **S**et **C**omputer). RISC is significantly faster and more efficient. As the industry recognized the value of smaller instruction sets, Intel was locked into the more complex x86 instruction. As a result, most Intel chips in the last few decades are RISC cores that have an x86 translator sitting between the core chip and the operating system. In other words, your computer [^arm] is a much more efficient CPU pretending to be a much less efficient CPU because of some inadvertent technical debt Intel accrued in the 1970s.

For the rest of this post, I am going to talk about my experience with technical debt and my website before asking a little after what role discussions of technical debt might play in the conversation surrounding digital humanities projects.

## The Early Days of Static Site Generators

I initially switched my website from Wordpress to Middleman in August 2013 [^august] because I was tired of struggling with Wordpress to get it to do what I wanted. My graduate school era personal website was conceptually similar to my current one in that both packed a series of discreet document together into a combined whole. The older site was [accordion](https://jqueryui.com/accordion/)-based and had the standard "About", "CV", "Teaching", and "Research" sections of most academic websites, but all displayed on the same page.

It turns out it is very hard, though not impossible, to get Wordpress to do this. Wordpress is an easy tool for making discreet pages but you essentially have to trick it into displaying multiple documents on the same page. I forget exactly what happened, but I think Wordpress released an API change that broke the loop-hole I was using to pack documents and I had to figure out something that would natively do what I want.

Which is why I made the switch to a [static site generator](https://davidwalsh.name/introduction-static-site-generators). While the idea of building a static site with a generating tool has become much more common in the last few years (primarily thanks to the wild success of Jekyll and Github Pages), in 2013 I think the technology was still fairly new. Jekyll was first released in 2008 but wouldn't be released in it's 1.0 version until June, 2013. At the time it was very rudimentary, while Middleman was extremely powerful.

I think Middleman's power is ultimately what led me to accrue what I am now recognizing as some pretty significant technical debt. Where Jekyll supported the Liquid templating language, Middleman supported pretty much *any* templating language available in Ruby (which was most of them at the time). Moreover, the key feature---data-driven pages---I was planning to use for my new website wasn't implemented yet in Jekyll (it would be first supported in September 2013, a month after I launched my new site).

Where I got into trouble with Middleman was through it's use of eRuby and HAML templating, both of which allow you to write Ruby code directly in your templates. This is great if you are trying to quickly implement some pretty complex features, for instance my static website pulls course data from an API I wrote when it builds to always, automatically display the courses I am currently teaching. Being able to do this directly in the template was great, but as there aren't any other static site generators with wide user base that support HAML and eRuby templates (which allow embedding Ruby directly in the template), I realized that the freedom I needed to solve the problems I had without the kind of hacks I'd implemented in Wordpress ultimately led to me being chained to Middleman and HAML.

Ultimately, HAML caused me to stop paying interest on my technical debt. Without going into too much detail, the 4.0 release of Middleman broke a very particular, very unusual use-case for HAML that, as far as I can tell, one person other than me has ever encountered. Really, what we were trying to do is something you shouldn't be doing with a website (regardless of what technology you are using), but I was trying to solve a particular problem in the quickest and clearest way possible. Anyway, I figured out how to fix the error I was having and forgot about. In the recent release of Middleman, the changed something that broke my fix. I was either going to have to spend another day or two figuring out a patch or just abandon the original code base. I chose the latter and I'm really glad I did.

I've learned since rewriting my site in Jekyll that---at least as of the 3.x branch of the software---I can actually do everything I thought I need Middleman for, but to do so, I have to think in terms of the constraints Jekyll places on how you write code. For instance, I reimplemented a the computationally intense aspects of the old site as custom Liquid commands. And, while it adds an additional layer of conceptual complexity, everything works.

Looking back on my old website, I can see how much I was doing to service the technical debt being tied to Middleman had left me with. With the 4.0 release, the Middleman authors chose to de-emphasize a utility called [Sprockets](https://github.com/rails/sprockets). Sprockets was the original asset manager for Ruby on Rails and, to put it nicely, it's very quirky. Many Rails apps have moved away from Sprockets, replacing it with something like [Grunt](https://gruntjs.com/) or [Webpack](https://webpack.js.org/). Middleman made the same decisions, so I was stuck reimplementing my website's Javascript and CSS compilation in Webpack. Now, I had a bunch of JavaScript tooling hanging around in my Ruby static site generator. Moreover, the external asset compilers were *very* slow in Middleman.

So, all told, my site is faster and simpler now that it is in Jekyll. I feel like I've cleared my technical debt from 2013 and feel like I've learned a lot about making better project-planning decisions. Though, at the same time, I can't help thinking that I actually haven't anything.

While I recognize now that Jekyll is the tool I should have been using, how much of that is because Jekyll has matured into a stable and powerful tool, while Middleman has fragmented a bit and become unwieldy because of the original project goals (which were broader than Jekyll's). At the time I was writing the first version of my site, Jekyll didn't support the features I needed and, moreover, until I was forced to really think it through, I wasn't sure it supported them at all. At the time I made the right decision, but as time progressed, the amount of work it takes to service my project became an increasing burden.

## Technical Debt in DH Projects

[^arm]: Unless you're reading this on a cellphone or tablet, which use an ARM archictecture and are not x86-based.
[^august]: There is a long history of me working on my website in August; I wonder why?
